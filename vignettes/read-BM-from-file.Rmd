---
title: "Read a BM from a file"
# author: "Florian Priv√©"
# date: "15 avril 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(bigstatsr)
```

In this vignette, you will learn how to read a `big.matrix` from a text file. 
We will see how to use function `big_readBM` through examples.

## First example

### Store a fake file
```{r}
N <- 10 
M <- 5
(x <- matrix(rnorm(N * M), nrow = N, dimnames = list(letters[1:N], LETTERS[1:M])))
write.table(x, tmp <- tempfile(), quote = FALSE)
```

### Get some intuition on the file format

I think it is always a good idea to print the first lines of the file you are interested in reading.
```{r}
readLines(tmp, 3)
```

What you can see with these first 3 lines:

- the first line of the file stores some names,
- the first element of following lines stores also some names,
- the elements are doubles,
- the elements are separated by a space.

### Read the file

```{r}
# See how the options corresponds to what we have seen 
# when reading the first 3 lines of the file
test <- big_readBM(tmp,
                   file.nheader = 1,      # default is 0
                   info.nelem = 1,        # default is 0
                   split = " ",           # the default
                   read.what = double(),  # the default
                   descriptor = FALSE)    # default is TRUE
```

```{r}
# print the `big.matrix` elements
test[,]
```

### Understand the resulting object

There are at least 2 things to note:

1. where are the names?
  
    The extra info are stored as attributes of the resulting object. You can 
    add dimnames to a `big.matrix` but I think it may not be a good idea. 
    Moreover, the names of the header won't be formatted like you want them to.
    The reason is that a header can be many things, and parsing it is difficult.

    ```{r}
    (info <- attr(test, "info")) # a matrix (info.nelem x read.nline)
    (colnames <- info[1, ])
    (header <- attr(test, "header"))  # one single string
    (rownames <- strsplit(header, split = " ", fixed = TRUE)[[1]])
    ```

    
2. the resulting matrix is the transpose of the initial one.


    A file is read line by line and a matrix should be stored column by column in order to preserve locality of accesses. So in order to efficiently read the file, each line should be a column of the resulting `big.matrix`. If it is not how you write it, you should ask yourself if your `write` function is efficient.
    
    If you want the transposed `big.matrix`, you can use the `transpose` parameter.

    ```{r}
    str(test <- big_readBM(tmp,
                           file.nheader = 1,     
                           info.nelem = 1,     
                           transpose = TRUE,
                           descriptor = FALSE))
    test[,] - x
    ```

## Second example

### A genotype file

```{r}
pedfile <- system.file("extdata", "example.ped", package = "bigstatsr")
cat(readLines(pedfile), sep = "\n")
```

### Get some intuition on the file format

```{r}
readLines(pedfile, 2)
```

What you can see with these first 2 lines:

- there is no header lines,
- the first 6 elements of each line are different from the rest of the line (they are info on each sample),
- the elements are characters ("A", "C", "T" or "G") and zeros are encoding missing values,
- the elements are separated by a space.

### Defining a transformation function

Basically, the letters are grouped by pairs and we compare the number of these letters that are different from a reference. So, each pair can have either 0, 1 or 2 letters that differ from the reference.

Let us make a function that regroup these letters by pairs and count the number that are different from the corresponding reference:

```{r}
ACTG <- c("A", "C", "T", "G")
ref <- match(c("T", "T", "G", "C", "C", "T", "G", "C"), ACTG)
transfo <- function(read) {
  read.int <- match(read, ACTG)
  (read.int[c(TRUE, FALSE)] != ref) + (read.int[c(FALSE, TRUE)] != ref)
}
```

In this function, we have a vector of letters as input, and a vector of half the input length as output which are now 0, 1 or 2. We can therefore store these values with one-byte integers (for example, with type `"char"`).

### Read the matrix

```{r}
# silently down cast from integer to char
options(bigmemory.typecast.warning = FALSE)
# read
str(test <- big_readBM(pedfile,
                       info.nelem = 6,
                       read.what = character(),
                       read.transfo = transfo,
                       BM.type = "char",
                       transpose = TRUE))
attach.BM(test)[,]
```

```{r}
t(attr(test, "info"))
```


## Final note

You should see the `...` parameter. I think it is usually a good idea to use filebacked `big.matrix` objects (not the case here) because you can write them once and attach them later on. Moreover, you have usually a very large amount of available disk space, but a limited amount of RAM or shared memory.
